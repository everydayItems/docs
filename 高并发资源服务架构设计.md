# 高并发资源服务架构设计

> 本文档对比主流高并发扣减方案，分析选型依据，并详细介绍资源服务的最终实现。

## 目录

1. [问题背景](#一问题背景)
2. [方案总览与对比](#二方案总览与对比)
3. [数据库层方案](#三数据库层方案)
4. [缓存层方案](#四缓存层方案)
5. [消息队列方案](#五消息队列方案)
6. [分布式事务方案](#六分布式事务方案)
7. [选型分析](#七选型分析)
8. [最终方案实现](#八最终方案实现)
9. [进阶优化方向](#九进阶优化方向)
10. [附录](#附录)

---

## 一、问题背景

### 1.1 业务场景

在线服务核心业务特点：

- **高并发**：每个请求都需要扣减用户资源（积分/余额/次数等）
- **实时性**：扣减必须在业务处理前完成（同步）
- **持久化**：资源数据不能丢失
- **热点用户**：部分用户请求量极大

### 1.2 问题现象

MySQL 监控出现行锁等待告警（`innodb_row_lock_waits = 12`），热点用户的并发请求导致响应延迟急剧上升。

### 1.3 核心需求

| 需求 | 说明 | 优先级 |
|------|------|--------|
| 防止超卖/多扣 | 余额不足时拒绝，不能多扣 | P0 |
| 高并发 | 支持 5万+ QPS | P0 |
| 低延迟 | 响应时间 < 5ms | P0 |
| 数据持久化 | 资源数据不能丢失 | P0 |
| 高可用 | 单点故障不影响服务 | P1 |
| 幂等性 | 重复请求不重复扣减 | P1 |

### 1.4 原方案分析

**原方案：MySQL CAS 乐观锁**

优化前采用的是**数据库乐观锁（CAS）**方案，直接在 MySQL 中执行原子更新：

```go
// 原方案：MySQL CAS 扣减
func (s *Service) DeductResource(userID int, amount int64) error {
    result := s.db.Exec(`
        UPDATE users
        SET balance = balance - ?, used = used + ?
        WHERE id = ? AND balance >= ?
    `, amount, amount, userID, amount)

    if result.RowsAffected == 0 {
        return errors.New("insufficient balance")
    }
    return nil
}
```

**问题现象**

监控告警显示行锁等待：

```
监控指标: innodb_row_lock_waits
当前值: 12
```

事务快照分析：

```sql
-- 用户 A: 4个并发事务竞争同一行
UPDATE `users` SET `balance`=balance + 2400, `used`=used - 2400
WHERE id = 1001 AND `users`.`deleted_at` IS NULL

-- 用户 B: 1个事务等待
UPDATE `users` SET `balance`=balance + 1800, `used`=used - 1800
WHERE id = 1002 AND `users`.`deleted_at` IS NULL
```

**问题根因**

| 问题 | 说明 |
|------|------|
| 行锁竞争 | 同一用户的多个并发请求竞争同一行，InnoDB 行锁导致串行执行 |
| 热点用户阻塞 | 高频用户的请求排队等待，响应时间急剧上升 |
| 连接池压力 | 等待锁的事务占用数据库连接，高并发下易耗尽连接池 |
| 无幂等控制 | 网络重试可能导致重复扣减 |

**性能瓶颈**

```
┌─────────────────────────────────────────────────────────────────────┐
│                    MySQL CAS 方案性能分析                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  并发请求 ──▶ 同一用户 ──▶ 同一行 ──▶ 行锁竞争 ──▶ 串行执行        │
│                                                                     │
│  Request 1 ────────────▶ [执行中]                                   │
│  Request 2 ────────────▶ [等待锁] ────▶ [执行中]                    │
│  Request 3 ────────────▶ [等待锁] ────▶ [等待锁] ────▶ [执行中]     │
│  Request 4 ────────────▶ [等待锁] ────▶ [等待锁] ────▶ [等待锁]...  │
│                                                                     │
│  结果: 热点用户响应时间 = N × 单次执行时间                          │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 二、方案总览与对比

### 2.1 主流方案一览

| 方案类别 | 具体方案 | 适用场景 |
|---------|---------|---------|
| 数据库层 | 悲观锁、乐观锁、唯一索引、分库分表 | 低并发、强一致性 |
| 缓存层 | Redis Lua、分布式锁、库存预占、多级缓存 | 高并发、低延迟 |
| 消息队列 | Kafka、RocketMQ、RabbitMQ、Asynq | 削峰填谷、异步处理 |
| 分布式事务 | TCC、Saga、本地消息表 | 跨服务事务 |

### 2.2 性能对比

| 方案 | 写延迟 | 读延迟 | QPS | 热点处理 | 适用场景 |
|------|--------|--------|-----|----------|---------|
| 悲观锁 | 20-50ms | 1-5ms | 500 | ❌ | 低并发 |
| 乐观锁 | 5-20ms | 1-5ms | 3K | ❌ | 中低并发 |
| Redis Lua | <1ms | <0.5ms | 100K | ✅ | 高并发 |
| 分布式锁 | 10-50ms | 1-5ms | 1K | ❌ | 资源互斥 |
| Kafka | 5-10ms | - | 100K | ✅ | 异步处理 |
| Asynq | 1-5ms | - | 50K | ✅ | 轻量异步 |
| RocketMQ 事务 | 20-50ms | - | 50K | ✅ | 事务消息 |
| TCC | 30-100ms | - | 5K | ✅ | 分布式事务 |

### 2.3 一致性对比

| 方案 | 一致性 | 超卖风险 | 多扣风险 | 数据丢失风险 |
|------|--------|----------|----------|-------------|
| 悲观锁 | 强一致 | ✅ 无 | ✅ 无 | ✅ 无 |
| 乐观锁 | 强一致 | ✅ 无 | ✅ 无 | ✅ 无 |
| Redis Lua | 最终一致 | ✅ 无 | ✅ 无 | 低（5秒窗口） |
| Kafka | 最终一致 | ✅ 无 | ✅ 无 | 低 |
| Asynq | 最终一致 | ✅ 无 | ✅ 无 | 低 |
| TCC | 强一致 | ✅ 无 | ✅ 无 | ✅ 无 |

### 2.4 复杂度对比

| 方案 | 代码量 | 新组件 | 运维成本 | 学习曲线 |
|------|--------|--------|----------|----------|
| 悲观锁 | 低 | 无 | 低 | 低 |
| 乐观锁 | 低 | 无 | 低 | 低 |
| Redis Lua | 中 | Redis | 中 | 中 |
| Kafka | 高 | Kafka+ZK | 高 | 高 |
| Asynq | 低 | Redis | 低 | 低 |
| RocketMQ | 高 | RocketMQ | 高 | 高 |
| TCC | 高 | Seata | 高 | 高 |

---

## 三、数据库层方案

### 3.1 悲观锁（SELECT FOR UPDATE）

**原理**

在读取数据时加排他锁，阻止其他事务访问，直到当前事务提交。

**实现**

```go
func (s *Service) DeductWithPessimisticLock(ctx context.Context, userID int, amount int64) error {
    return s.db.Transaction(func(tx *gorm.DB) error {
        var user User
        if err := tx.Raw(`
            SELECT id, balance FROM users WHERE id = ? FOR UPDATE
        `, userID).Scan(&user).Error; err != nil {
            return err
        }

        if user.Balance < amount {
            return errors.New("insufficient balance")
        }

        return tx.Exec(`
            UPDATE users SET balance = balance - ?, used = used + ?
            WHERE id = ?
        `, amount, amount, userID).Error
    })
}
```

**评估**

| 维度 | 评价 |
|------|------|
| 优点 | 强一致性、实现简单、无超卖 |
| 缺点 | 性能差（串行）、死锁风险、热点阻塞 |
| QPS | 500-1000 |
| 延迟 | 20-50ms |

### 3.2 乐观锁（CAS + 版本号）

**原理**

不加锁读取数据，更新时检查数据是否被修改，若被修改则重试。

**实现**

```go
// 方式一：版本号
func (s *Service) DeductWithVersion(ctx context.Context, userID int, amount int64) error {
    maxRetries := 3
    for i := 0; i < maxRetries; i++ {
        var user struct {
            Balance int64
            Version int64
        }
        s.db.Raw("SELECT balance, version FROM users WHERE id = ?", userID).Scan(&user)

        if user.Balance < amount {
            return errors.New("insufficient balance")
        }

        result := s.db.Exec(`
            UPDATE users SET balance = balance - ?, version = version + 1
            WHERE id = ? AND version = ?
        `, amount, userID, user.Version)

        if result.RowsAffected > 0 {
            return nil
        }
        time.Sleep(time.Millisecond * 10 * time.Duration(i+1))
    }
    return errors.New("max retries exceeded")
}

// 方式二：条件检查（更简洁）
func (s *Service) DeductWithCAS(ctx context.Context, userID int, amount int64) error {
    result := s.db.Exec(`
        UPDATE users SET balance = balance - ?, used = used + ?
        WHERE id = ? AND balance >= ?
    `, amount, amount, userID, amount)

    if result.RowsAffected == 0 {
        return errors.New("insufficient balance")
    }
    return nil
}
```

**评估**

| 维度 | 评价 |
|------|------|
| 优点 | 无锁阻塞、无死锁、实现简单 |
| 缺点 | 高并发重试频繁、热点竞争、可能饥饿 |
| QPS | 2000-5000 |
| 延迟 | 5-20ms |

### 3.3 唯一索引防重

**原理**

利用数据库唯一索引特性实现幂等性。

**实现**

```sql
CREATE TABLE resource_records (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    request_id VARCHAR(64) NOT NULL,
    user_id INT NOT NULL,
    amount BIGINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY uk_request_id (request_id)
);
```

```go
func (s *Service) DeductWithUniqueIndex(ctx context.Context, req *DeductRequest) error {
    return s.db.Transaction(func(tx *gorm.DB) error {
        err := tx.Exec(`
            INSERT INTO resource_records (request_id, user_id, amount) VALUES (?, ?, ?)
        `, req.RequestID, req.UserID, req.Amount).Error

        if isDuplicateKeyError(err) {
            return nil // 重复请求
        }
        if err != nil {
            return err
        }

        return tx.Exec(`
            UPDATE users SET balance = balance - ? WHERE id = ? AND balance >= ?
        `, req.Amount, req.UserID, req.Amount).Error
    })
}
```

### 3.4 分库分表

**原理**

将热点数据分散到多个库/表，降低单点压力。

**架构**

```
原始: users 表 (单点热点)
     ↓
分片: users_0, users_1, users_2, users_3
      shard_key = user_id % 4
```

**评估**

| 维度 | 评价 |
|------|------|
| 优点 | 水平扩展、分散热点 |
| 缺点 | 架构复杂、跨分片查询困难、运维成本高 |
| 适用 | 数据量大、需要水平扩展 |

---

## 四、缓存层方案

### 4.1 Redis Lua 脚本

**原理**

利用 Redis 单线程执行 Lua 脚本的特性，将多个操作合并为原子操作。

**为什么是原子的？**

```
┌─────────────────────────────────────────────────────────┐
│                 Redis 单线程模型                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  请求队列              主线程                           │
│  ┌─────┐              ┌────────────────────────┐       │
│  │ R1  │ ────────────▶│                        │       │
│  ├─────┤    排队      │   Lua 脚本执行中...    │       │
│  │ R2  │ ────────────▶│   (不可中断)          │       │
│  ├─────┤    排队      │                        │       │
│  │ R3  │ ────────────▶│   ① EXISTS            │       │
│  └─────┘              │   ② HGET              │       │
│                       │   ③ HINCRBY           │       │
│                       │   ④ RPUSH             │       │
│                       │   ⑤ SETEX             │       │
│                       └────────────────────────┘       │
│                                                         │
│  ⭐ 整个 Lua 脚本作为一个原子操作，其他请求必须等待     │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**评估**

| 维度 | 评价 |
|------|------|
| 优点 | 原子性、极低延迟（<1ms）、高并发（100K QPS）、无锁 |
| 缺点 | Lua 调试困难、内存限制、需异步落库 |
| QPS | 50000-100000 |
| 延迟 | 0.5-2ms |

### 4.2 Redis 分布式锁（Redlock）

**原理**

使用 Redis 实现分布式锁，确保同一时刻只有一个请求能操作资源。

**实现**

```go
import "github.com/go-redsync/redsync/v4"

func (s *Service) DeductWithLock(ctx context.Context, req *DeductRequest) error {
    mutex := s.redsync.NewMutex(
        fmt.Sprintf("lock:user:%d", req.UserID),
        redsync.WithExpiry(10*time.Second),
    )

    if err := mutex.LockContext(ctx); err != nil {
        return err
    }
    defer mutex.UnlockContext(ctx)

    return s.doDeduct(ctx, req)
}
```

**评估**

| 维度 | 评价 |
|------|------|
| 优点 | 分布式互斥、防止并发冲突 |
| 缺点 | 串行化执行、性能瓶颈、与悲观锁本质相同 |
| 结论 | 不推荐，对于扣减场景 Redis Lua 更优 |

### 4.3 库存预占（Redis 预扣减）

**原理**

先在 Redis 预扣减，成功后异步同步到数据库。

**流程**

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  API 请求   │────▶│Redis 预扣减 │────▶│  立即返回   │
└─────────────┘     │  (< 1ms)    │     │  (成功)     │
                    └──────┬──────┘     └─────────────┘
                           │
                           │ 异步 (5秒批量)
                           ▼
                    ┌─────────────┐
                    │  MySQL 落库 │
                    └─────────────┘
```

### 4.4 本地缓存 + 多级缓存

**架构**

```
L1: 本地缓存 (sync.Map)    → 0.01ms，快速拒绝
     ↓ 未命中
L2: Redis 缓存             → 1ms，原子扣减
     ↓ 未命中
L3: MySQL 数据库           → 5-20ms，持久化
```

**实现**

```go
func (s *Service) Deduct(ctx context.Context, req *DeductRequest) (*DeductResult, error) {
    // L1: 本地缓存快速拒绝
    if entry, ok := s.localCache.Load(req.UserID); ok {
        cached := entry.(*CacheEntry)
        if time.Now().Before(cached.ExpireAt) && cached.Balance < req.Amount {
            return &DeductResult{Success: false, ErrorCode: ErrCodeInsufficientBalance}, nil
        }
    }

    // L2: Redis 扣减
    result, err := s.deductFromRedis(ctx, req)
    if err != nil {
        // L3: 降级 MySQL
        return s.deductFromMySQL(ctx, req)
    }

    // 更新 L1
    if result.Success {
        s.localCache.Store(req.UserID, &CacheEntry{
            Balance:  result.BalanceAfter,
            ExpireAt: time.Now().Add(5 * time.Second),
        })
    }

    return result, nil
}
```

---

## 五、消息队列方案

### 5.1 Kafka

**架构**

```
┌─────────────────────────────────────────────────────────────────────┐
│                     Kafka 异步扣减架构                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │  Topic: resource_deduct (Partitions: 8, Replication: 3)     │   │
│   │  ┌────┐ ┌────┐ ┌────┐ ┌────┐ ┌────┐ ┌────┐ ┌────┐ ┌────┐   │   │
│   │  │ P0 │ │ P1 │ │ P2 │ │ P3 │ │ P4 │ │ P5 │ │ P6 │ │ P7 │   │   │
│   │  └────┘ └────┘ └────┘ └────┘ └────┘ └────┘ └────┘ └────┘   │   │
│   │                                                             │   │
│   │  分区策略: partition = hash(user_id) % 8                    │   │
│   │  保证同一用户的消息顺序消费                                 │   │
│   └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│   流量: 100K QPS → 削峰 → 2K QPS (批量)                            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**评估**

| 维度 | 评价 |
|------|------|
| 优点 | 削峰填谷、高吞吐（100万+/秒）、消息持久化、解耦 |
| 缺点 | 延迟增加（秒级）、运维复杂、需要 ZooKeeper |
| 适用 | 大规模异步处理、日志采集 |

### 5.2 RocketMQ 事务消息

**原理**

RocketMQ 提供事务消息机制，保证本地事务和消息发送的一致性。

**流程**

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  发送半消息 │────▶│  执行本地   │────▶│  Commit/    │
│  (Half Msg) │     │  事务       │     │  Rollback   │
└─────────────┘     └─────────────┘     └─────────────┘
                           │
                           │ 超时未响应
                           ▼
                    ┌─────────────┐
                    │  回查机制   │
                    │  检查事务   │
                    │  状态       │
                    └─────────────┘
```

**评估**

| 维度 | 评价 |
|------|------|
| 优点 | 事务消息、延迟队列、顺序消息 |
| 缺点 | 运维复杂、依赖 NameServer |
| 适用 | 需要事务消息保证的场景 |

### 5.3 RabbitMQ 延迟队列

**场景**

预占资源，30分钟后未确认则自动释放。

**实现**

```go
func (p *Producer) SendDelayMessage(req *DeductRequest, delay time.Duration) error {
    return p.channel.Publish(
        "resource.delayed.exchange",
        "resource.release",
        false, false,
        amqp.Publishing{
            Body: req.ToJSON(),
            Headers: amqp.Table{
                "x-delay": delay.Milliseconds(),
            },
        },
    )
}
```

**评估**

| 维度 | 评价 |
|------|------|
| 优点 | 精确延迟、微秒级延迟、协议丰富 |
| 缺点 | 吞吐量低（5万/秒）、单机瓶颈 |
| 适用 | 延迟队列、任务调度 |

### 5.4 Asynq（基于 Redis）

**原理**

Asynq 是基于 Redis 的轻量级任务队列，Go 语言原生支持，适合中小规模异步任务。

**架构**

```
┌─────────────────────────────────────────────────────────────────────┐
│                      Asynq 异步任务架构                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   ┌─────────────┐     ┌─────────────┐     ┌─────────────┐          │
│   │  API Server │────▶│   Redis     │◀────│  Worker     │          │
│   │  (生产者)   │     │  (队列)     │     │  (消费者)   │          │
│   └─────────────┘     └─────────────┘     └─────────────┘          │
│                                                                     │
│   特点:                                                             │
│   - 基于 Redis，无需额外组件                                        │
│   - 支持任务重试、延迟任务、定时任务                                │
│   - Go 原生，API 简洁                                               │
│   - 支持任务优先级和队列隔离                                        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**实现**

```go
import "github.com/hibiken/asynq"

// 定义任务类型
const TypeResourceSync = "resource:sync"

// 任务 Payload
type ResourceSyncPayload struct {
    UserID    int    `json:"user_id"`
    Delta     int64  `json:"delta"`
    RequestID string `json:"request_id"`
}

// 生产者：创建任务
func (s *Service) EnqueueSync(ctx context.Context, payload *ResourceSyncPayload) error {
    data, _ := json.Marshal(payload)
    task := asynq.NewTask(TypeResourceSync, data,
        asynq.MaxRetry(3),
        asynq.Timeout(30*time.Second),
        asynq.Queue("resource"),
    )
    _, err := s.client.Enqueue(task)
    return err
}

// 消费者：处理任务
func (h *ResourceHandler) HandleResourceSync(ctx context.Context, t *asynq.Task) error {
    var p ResourceSyncPayload
    json.Unmarshal(t.Payload(), &p)

    return h.db.Exec(`
        UPDATE users SET balance = balance + ?, used = used - ?
        WHERE id = ?
    `, p.Delta, p.Delta, p.UserID).Error
}

// 启动 Worker
func StartWorker(redisAddr string) {
    srv := asynq.NewServer(
        asynq.RedisClientOpt{Addr: redisAddr},
        asynq.Config{
            Concurrency: 10,
            Queues: map[string]int{
                "resource": 6,
                "default":  3,
            },
        },
    )

    mux := asynq.NewServeMux()
    mux.HandleFunc(TypeResourceSync, handler.HandleResourceSync)

    srv.Run(mux)
}
```

**评估**

| 维度 | 评价 |
|------|------|
| 优点 | 轻量（仅依赖 Redis）、Go 原生、API 简洁、支持重试/延迟/定时 |
| 缺点 | 吞吐量受 Redis 限制、不支持消息回溯 |
| QPS | 10000-50000 |
| 适用 | Go 项目、中小规模异步任务、已有 Redis 基础设施 |

### 5.5 消息队列对比

| 特性 | Kafka | RocketMQ | RabbitMQ | Asynq |
|------|-------|----------|----------|-------|
| 吞吐量 | 100万+/秒 | 50万/秒 | 5万/秒 | 5万/秒 |
| 延迟 | 毫秒级 | 毫秒级 | 微秒级 | 毫秒级 |
| 事务消息 | ❌ | ✅ | ❌ | ❌ |
| 延迟队列 | ❌ | ✅ | ✅ | ✅ |
| 顺序消息 | ✅ (分区) | ✅ | ✅ | ✅ (队列) |
| 持久化 | ✅ | ✅ | ✅ | ✅ (Redis) |
| 运维复杂度 | 高 | 高 | 中 | 低 |
| 依赖组件 | ZooKeeper | NameServer | Erlang | Redis |
| Go 支持 | 中 | 中 | 中 | 原生 |

---

## 六、分布式事务方案

### 6.1 TCC（Try-Confirm-Cancel）

**流程**

```
┌─────────────────────────────────────────────────────────────────────┐
│  Phase 1: Try (预留资源)                                            │
│  ┌─────────────┐            ┌─────────────┐                        │
│  │ 资源服务     │            │ 库存服务     │                        │
│  │ 冻结 100    │            │ 冻结 1 件    │                        │
│  └─────────────┘            └─────────────┘                        │
├─────────────────────────────────────────────────────────────────────┤
│  Phase 2: Confirm (全部成功) 或 Cancel (任一失败)                   │
│  Confirm: 冻结 → 扣减                                               │
│  Cancel:  冻结 → 释放                                               │
└─────────────────────────────────────────────────────────────────────┘
```

**评估**

| 维度 | 评价 |
|------|------|
| 优点 | 强一致性、灵活性高 |
| 缺点 | 实现复杂、需要三个接口、性能开销大 |
| 适用 | 跨服务分布式事务、金融场景 |

### 6.2 Saga 模式

**流程**

```
正向流程：T1 → T2 → T3 → T4
补偿流程：C4 ← C3 ← C2 ← C1

失败时逆序执行补偿操作
```

**评估**

| 维度 | 评价 |
|------|------|
| 优点 | 长事务支持、最终一致性 |
| 缺点 | 补偿逻辑复杂、可能出现中间状态 |
| 适用 | 长流程业务、微服务编排 |

### 6.3 本地消息表

**原理**

将消息和业务数据写入同一个数据库事务。

**实现**

```go
func (s *Service) DeductWithOutbox(ctx context.Context, req *DeductRequest) error {
    return s.db.Transaction(func(tx *gorm.DB) error {
        tx.Exec("UPDATE users SET balance = balance - ? WHERE id = ?", req.Amount, req.UserID)

        tx.Create(&Outbox{
            Topic:   "resource_changed",
            Payload: req.ToJSON(),
            Status:  0,
        })
        return nil
    })
}

// 定时任务发送消息
func (s *Service) SendPendingMessages() {
    var messages []Outbox
    s.db.Where("status = 0").Limit(100).Find(&messages)

    for _, msg := range messages {
        if s.mq.Send(msg.Topic, msg.Payload) == nil {
            s.db.Model(&msg).Update("status", 1)
        }
    }
}
```

---

## 七、选型分析

### 7.1 需求匹配度分析

| 需求 | 悲观锁 | 乐观锁 | Redis Lua | Kafka | Asynq | TCC |
|------|--------|--------|-----------|-------|-------|-----|
| 高并发 5万+ QPS | ❌ | ❌ | ✅ | ✅ | ⚠️ | ❌ |
| 低延迟 < 5ms | ❌ | ⚠️ | ✅ | ❌ | ⚠️ | ❌ |
| 防止超卖 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| 幂等性 | ❌ | ❌ | ✅ | ⚠️ | ⚠️ | ✅ |
| 数据持久化 | ✅ | ✅ | ⚠️ | ✅ | ⚠️ | ✅ |
| 运维简单 | ✅ | ✅ | ✅ | ❌ | ✅ | ❌ |

### 7.2 为什么选择 Redis Lua + 异步落库？

**决策依据**

```
┌─────────────────────────────────────────────────────────────────────┐
│                         选型决策树                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Q1: 是否需要实时同步扣减？                                         │
│      → 是（API 调用前必须完成）                                     │
│      → 排除：纯消息队列异步方案                                     │
│                                                                     │
│  Q2: QPS 要求？                                                     │
│      → 5万+                                                         │
│      → 排除：数据库锁方案（最高 5K）                                │
│                                                                     │
│  Q3: 延迟要求？                                                     │
│      → < 5ms                                                        │
│      → 排除：分布式事务（30-100ms）                                 │
│                                                                     │
│  Q4: 是否已有 Redis？                                               │
│      → 是                                                           │
│      → 选择：Redis Lua 方案                                         │
│                                                                     │
│  Q5: 数据持久化如何保证？                                           │
│      → 异步落库 + 定时对账                                          │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**核心优势**

| 优势 | 说明 |
|------|------|
| 极致性能 | Redis 单线程 Lua 脚本，< 1ms 延迟，100K QPS |
| 原子性保证 | Lua 脚本不可中断，天然原子操作 |
| 内置幂等 | 脚本内检查 RequestID，无需额外组件 |
| 热点友好 | 单用户高并发不影响其他用户 |
| 降级兜底 | Redis 故障自动切换 MySQL CAS |
| 最终一致 | 异步落库 + 定时对账，数据不丢失 |

**权衡取舍**

| 取舍 | 选择 | 理由 |
|------|------|------|
| 强一致 vs 最终一致 | 最终一致 | 5秒窗口可接受，对账兜底 |
| 性能 vs 复杂度 | 中等复杂度 | Redis Lua 学习曲线可控 |
| 实时 vs 异步 | 扣减实时 + 落库异步 | 兼顾性能和可靠性 |

---

## 八、最终方案实现

### 8.0 快速入门

**初始化服务**

```go
import "app/service/resource"

func main() {
    // 初始化资源服务（需要先初始化 Redis 和 DB）
    if err := resource.Init(resource.DefaultConfig()); err != nil {
        log.Fatalf("Failed to init resource service: %v", err)
    }

    // 启动异步落库 Worker
    svc := resource.GetService()
    syncWorker := resource.NewSyncWorker(resource.DefaultConfig(), svc)
    syncWorker.Start(context.Background())
    defer syncWorker.Stop()

    // 启动对账服务
    reconciler := resource.NewReconciler(resource.DefaultConfig(), svc)
    reconciler.Start(context.Background())
    defer reconciler.Stop()
}
```

**扣减资源**

```go
svc := resource.GetService()
result, err := svc.Deduct(ctx, &resource.DeductRequest{
    UserID:    userID,
    Amount:    int64(amountNeeded),
    RequestID: requestID,  // 幂等键
    Reason:    "service_call",
})

if err != nil || !result.Success {
    if result.ErrorCode == resource.ErrCodeInsufficientBalance {
        // 余额不足
    }
}
```

**增加 & 退还资源**

```go
// 增加资源
svc.Recharge(ctx, &resource.RechargeRequest{
    UserID: userID, Amount: amount, RequestID: orderNo, Reason: "recharge",
})

// 退还资源（操作失败时）
svc.Refund(ctx, &resource.RechargeRequest{
    UserID: userID, Amount: amount, RequestID: "refund_"+requestID, Reason: "operation_failed",
})
```

**文件结构**

```
service/resource/
├── types.go          # 数据结构、配置、错误码定义
├── lua_scripts.go    # Redis Lua 脚本（原子操作核心）
├── service.go        # 资源服务主实现
├── sync_worker.go    # 异步落库 Worker
├── reconciler.go     # 定时对账服务
└── metrics.go        # 监控指标
```

**配置说明**

```go
type Config struct {
    SyncInterval      time.Duration // 异步落库间隔，默认 5 秒
    SyncBatchSize     int           // 每批次同步数量，默认 1000
    ChangeLogMaxSize  int64         // 变更日志最大长度，默认 100000
    ReconcileInterval time.Duration // 对账间隔，默认 1 小时
    ReconcileEnabled  bool          // 是否启用对账，默认 true
    FallbackEnabled   bool          // 是否启用 MySQL 降级，默认 true
    RedisTimeout      time.Duration // Redis 超时时间，默认 100ms
    LocalCacheEnabled bool          // 是否启用本地缓存，默认 true
    LocalCacheTTL     time.Duration // 本地缓存过期时间，默认 5 秒
    IdempotentKeyTTL  time.Duration // 幂等键过期时间，默认 5 分钟
    UserKeyTTL        time.Duration // 用户资源 Key TTL，默认 30 天
}
```

### 8.1 技术栈组合

| 技术 | 采用情况 | 具体实现 | 理由 |
|------|----------|----------|------|
| 数据库悲观锁 | ❌ 未采用 | - | QPS 仅 500-1000，延迟 20-50ms，无法满足需求 |
| 数据库乐观锁（CAS） | ✅ 部分 | MySQL 降级时使用 | 无锁竞争，适合低并发兜底 |
| Redis + Lua 脚本 | ✅ 核心 | 原子扣减、幂等控制 | 单线程原子操作，<1ms 延迟，10万+ QPS |
| 异步落库 | ✅ 采用 | Redis List 变更日志 + SyncWorker | 解耦实时扣减与持久化 |
| 库存预占 | ✅ 采用 | Redis 预扣减，异步落库 | 先扣 Redis 保证实时性 |
| 本地缓存快速拒绝 | ✅ 采用 | 余额不足时 0ms 拒绝 | 减少无效 Redis 请求 |
| 幂等性控制 | ✅ 采用 | RequestID 去重 | 防止多扣 |
| 定时对账 | ✅ 采用 | Reconciler 修复差异 | 兜底机制 |
| 分布式锁 | ❌ 未采用 | - | 本质与悲观锁相同，串行化执行 |
| Kafka/RocketMQ | ❌ 未采用 | - | 运维复杂度高，Redis List 已满足需求 |
| TCC/Saga | ❌ 未采用 | - | 延迟 30-100ms 无法满足要求 |

### 8.2 架构图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              资源服务架构                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌─────────────┐                                                           │
│   │  API 请求   │                                                           │
│   └──────┬──────┘                                                           │
│          │                                                                  │
│          ▼                                                                  │
│   ┌─────────────────────────────────────────┐                               │
│   │  Layer 1: 本地缓存快速拒绝               │ ← 防止无效请求到达 Redis     │
│   │  if cache.balance < amount → reject     │   延迟: 0ms                  │
│   └──────────────────┬──────────────────────┘                               │
│                      │                                                      │
│                      ▼                                                      │
│   ┌─────────────────────────────────────────┐                               │
│   │  Layer 2: Redis Lua 原子扣减            │ ← 核心：原子性 + 幂等性       │
│   │  ┌─────────────────────────────────┐    │   延迟: < 1ms                │
│   │  │ ① 幂等检查 (EXISTS)            │    │                               │
│   │  │ ② 余额检查 (HGET)              │    │                               │
│   │  │ ③ 原子扣减 (HINCRBY)           │    │                               │
│   │  │ ④ 记录变更日志 (RPUSH)         │    │                               │
│   │  │ ⑤ 设置幂等键 (SETEX)           │    │                               │
│   │  └─────────────────────────────────┘    │                               │
│   └──────────────────┬──────────────────────┘                               │
│                      │                                                      │
│          ┌───────────┴───────────┐                                          │
│          │                       │                                          │
│          ▼                       ▼                                          │
│   ┌─────────────────┐    ┌─────────────────┐                                │
│   │ 变更日志队列     │    │  MySQL 降级     │ ← 兜底：乐观锁 CAS            │
│   │ resource:changelog│   │  (Redis故障时)  │                               │
│   └────────┬────────┘    └─────────────────┘                                │
│            │                                                                │
│            ▼                                                                │
│   ┌─────────────────┐    ┌─────────────────┐                                │
│   │  SyncWorker     │    │  Reconciler     │ ← 最终一致性保障               │
│   │  5秒批量落库    │    │  1小时对账修复  │                                │
│   └────────┬────────┘    └────────┬────────┘                                │
│            │                      │                                         │
│            └──────────┬───────────┘                                         │
│                       ▼                                                     │
│               ┌─────────────┐                                               │
│               │   MySQL     │                                               │
│               │  持久化存储  │                                               │
│               └─────────────┘                                               │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 8.3 核心 Lua 脚本

```lua
-- resource_deduct.lua：资源扣减脚本（原子操作）

local key = KEYS[1]                      -- resource:user:1001
local amount = tonumber(ARGV[1])         -- 100
local request_id = ARGV[2]               -- uuid
local reason = ARGV[3]                   -- "service_call"
local timestamp = ARGV[4]                -- 1705123456
local idempotent_ttl = tonumber(ARGV[5]) -- 300秒
local changelog_max = tonumber(ARGV[6])  -- 100000
local user_key_ttl = tonumber(ARGV[7])   -- 30天

-- JSON 转义函数
local function json_escape(s)
    if s == nil then return "" end
    s = tostring(s)
    s = s:gsub('\\', '\\\\')
    s = s:gsub('"', '\\"')
    s = s:gsub('\n', '\\n')
    s = s:gsub('\r', '\\r')
    s = s:gsub('\t', '\\t')
    return s
end

-- ① 幂等性检查：防止重复扣减
local idempotent_key = "resource:idempotent:" .. request_id
if redis.call('EXISTS', idempotent_key) == 1 then
    local cached = redis.call('GET', idempotent_key)
    return {-3, tonumber(cached), "duplicate request"}
end

-- ② 获取当前余额
local current = redis.call('HGET', key, 'balance')
if not current then
    return {-1, 0, "user not found"}
end
current = tonumber(current)

-- ③ 余额检查：防止超扣
if current < amount then
    return {-2, current, "insufficient balance"}
end

-- ④ 原子扣减
local new_balance = current - amount
redis.call('HSET', key, 'balance', new_balance)
redis.call('HINCRBY', key, 'used', amount)

-- ⑤ 刷新 TTL
if user_key_ttl > 0 then
    redis.call('EXPIRE', key, user_key_ttl)
end

-- ⑥ 记录幂等键
redis.call('SETEX', idempotent_key, idempotent_ttl, new_balance)

-- ⑦ 记录变更日志
local user_id = string.match(key, "resource:user:(%d+)")
local log_entry = string.format(
    '{"user_id":%s,"delta":%d,"reason":"%s","request_id":"%s","timestamp":%s}',
    user_id, -amount, json_escape(reason), json_escape(request_id), timestamp
)
redis.call('RPUSH', 'resource:changelog', log_entry)

-- ⑧ 控制队列长度
local log_len = redis.call('LLEN', 'resource:changelog')
if log_len > changelog_max then
    redis.call('LTRIM', 'resource:changelog', log_len - changelog_max, -1)
end

return {0, new_balance, "success"}
```

### 8.4 新旧方案对比

**为什么从 MySQL CAS 切换到 Redis Lua**

| 对比维度 | MySQL CAS（原方案） | Redis Lua（新方案） |
|----------|---------------------|---------------------|
| QPS | 2000-5000 | 50000+ |
| 延迟 | 5-20ms（热点用户 2s+） | < 1ms |
| 行锁等待 | 有（innodb_row_lock_waits = 12） | 无 |
| 热点处理 | ❌ 串行阻塞，同一用户请求排队 | ✅ 单线程顺序处理，无锁竞争 |
| 幂等性 | ❌ 无，网络重试可能多扣 | ✅ RequestID 去重 |
| 数据持久化 | ✅ 实时落库 | ⚠️ 异步落库（5秒窗口） |
| 一致性 | 强一致 | 最终一致（对账兜底） |

**优化效果**

| 指标 | 优化前 | 优化后 | 提升 |
|------|--------|--------|------|
| QPS | 1000-3000 | 50000+ | 16-50x |
| 延迟 | 5-20ms | < 1ms | 5-20x |
| innodb_row_lock_waits | 12 | 0 | 100% |
| 热点用户响应 | 2s+ | < 1ms | 2000x |
| 超卖风险 | 低（有锁） | 无 | ✅ |
| 多扣风险 | 有（无幂等） | 无 | ✅ |

**结论**

MySQL CAS 方案在低并发场景表现良好，但面对热点用户高并发时，行锁竞争成为瓶颈。Redis Lua 方案通过单线程模型彻底消除锁竞争，配合异步落库 + 定时对账保证数据最终一致性。

---

## 九、进阶优化方向

当前方案是业界主流实践，但仍有优化空间。以下是根据不同业务约束的进阶方案。

### 9.1 当前方案局限性

| 局限 | 说明 | 影响 |
|------|------|------|
| 5秒数据窗口 | Redis 宕机时最多丢 5 秒数据 | 对账可修复，但有短暂不一致 |
| 单 Redis 瓶颈 | 单实例上限约 10-20 万 QPS | 超大规模需要分片 |
| 异步落库复杂度 | 需要 SyncWorker + Reconciler | 运维成本增加 |
| Redis 内存成本 | 热数据常驻内存 | 用户量大时内存开销 |

### 9.2 优化方案 A：缩短同步窗口

**目标**：减少数据丢失风险

```
当前：5秒批量同步
改进：1秒同步
效果：数据窗口从 5秒 → 1秒，丢失风险降低 80%
代价：MySQL 写入频率增加 5 倍
```

**实现**：

```go
// 修改配置
config := &resource.Config{
    SyncInterval:  1 * time.Second,  // 从 5秒改为 1秒
    SyncBatchSize: 200,              // 批次相应减小
}
```

**适用场景**：对数据一致性要求较高，MySQL 写入压力可承受

### 9.3 优化方案 B：Redis Cluster 分片

**目标**：突破单实例 QPS 瓶颈

```
┌─────────────────────────────────────────────────────────────────────┐
│                     Redis Cluster 分片架构                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   user_id % 4 = 0 ──▶ Redis Node 0                                  │
│   user_id % 4 = 1 ──▶ Redis Node 1                                  │
│   user_id % 4 = 2 ──▶ Redis Node 2                                  │
│   user_id % 4 = 3 ──▶ Redis Node 3                                  │
│                                                                     │
│   效果：4 节点 × 10万 QPS = 40万 QPS                                │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**实现**：

```go
import "github.com/redis/go-redis/v9"

// 使用 Redis Cluster 客户端
rdb := redis.NewClusterClient(&redis.ClusterOptions{
    Addrs: []string{
        "redis-node-0:6379",
        "redis-node-1:6379",
        "redis-node-2:6379",
        "redis-node-3:6379",
    },
})

// Lua 脚本在 Cluster 模式下需要确保 Key 在同一 slot
// 使用 Hash Tag 保证同一用户的所有 Key 在同一节点
key := fmt.Sprintf("resource:{user:%d}", userID)  // {user:123} 是 Hash Tag
```

**适用场景**：QPS 超过 10 万，需要水平扩展

### 9.4 优化方案 C：本地预分配资源

**目标**：极致低延迟，减少 Redis 压力

```
┌─────────────────────────────────────────────────────────────────────┐
│                      本地预分配资源架构                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   启动时：从 Redis 预申请 1000 资源到本地                           │
│                                                                     │
│   ┌─────────────┐     ┌─────────────┐     ┌─────────────┐          │
│   │  API 请求   │────▶│  本地扣减   │────▶│  立即返回   │          │
│   └─────────────┘     │  (0.01ms)   │     └─────────────┘          │
│                       └──────┬──────┘                               │
│                              │                                      │
│                              │ 本地资源耗尽                         │
│                              ▼                                      │
│                       ┌─────────────┐                               │
│                       │ Redis 补充   │                               │
│                       │ 再申请 1000  │                               │
│                       └─────────────┘                               │
│                                                                     │
│   效果：90% 请求在本地完成，延迟从 1ms → 0.01ms                     │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**实现**：

```go
type LocalResourcePool struct {
    mu       sync.Mutex
    userPool map[int]*UserLocalResource
}

type UserLocalResource struct {
    Balance   int64     // 本地剩余资源
    ExpireAt  time.Time // 过期时间（防止长期占用）
}

func (p *LocalResourcePool) Deduct(userID int, amount int64) error {
    p.mu.Lock()
    defer p.mu.Unlock()

    local, ok := p.userPool[userID]
    if !ok || local.Balance < amount || time.Now().After(local.ExpireAt) {
        // 本地不足，从 Redis 补充
        newResource, err := p.refillFromRedis(userID, 1000)
        if err != nil {
            return err
        }
        local = &UserLocalResource{
            Balance:  newResource,
            ExpireAt: time.Now().Add(30 * time.Second),
        }
        p.userPool[userID] = local
    }

    if local.Balance < amount {
        return errors.New("insufficient balance")
    }

    local.Balance -= amount
    return nil
}

// 注意：节点故障时需要回收未使用的本地资源
func (p *LocalResourcePool) ReturnUnusedResource() {
    // 定时或优雅关闭时，将未用完的资源归还 Redis
}
```

**适用场景**：延迟要求极致（<0.1ms），可接受节点故障时的资源回收复杂度

### 9.5 优化方案 D：同步双写（强一致）

**目标**：数据零丢失，强一致性

```go
// 牺牲性能换强一致
func (s *Service) DeductWithDualWrite(ctx context.Context, req *DeductRequest) error {
    // 1. MySQL 先扣（事务，作为权威数据源）
    result := s.db.Exec(`
        UPDATE users SET balance = balance - ?, used = used + ?
        WHERE id = ? AND balance >= ?
    `, req.Amount, req.Amount, req.UserID, req.Amount)

    if result.RowsAffected == 0 {
        return errors.New("insufficient balance")
    }

    // 2. 同步更新 Redis（允许失败，查询时会从 MySQL 修复）
    key := fmt.Sprintf("resource:user:%d", req.UserID)
    s.rdb.HIncrBy(ctx, key, "balance", -req.Amount)
    s.rdb.HIncrBy(ctx, key, "used", req.Amount)

    return nil
}
```

**性能对比**：

| 指标 | 当前方案（Redis 优先） | 双写方案（MySQL 优先） |
|------|------------------------|------------------------|
| QPS | 50000+ | 3000-5000 |
| 延迟 | < 1ms | 5-10ms |
| 数据丢失 | 可能（5秒窗口） | 零丢失 |
| 一致性 | 最终一致 | 强一致 |

**适用场景**：金融级场景，数据绝对不能丢失，可接受性能下降

### 9.6 业界方案参考与选型

| 方案 | 复杂度 | 组件依赖 | 一致性 | QPS | 适用场景 |
|------|--------|----------|--------|-----|----------|
| 分库分表 + 乐观锁 | ⭐ | 只有 MySQL | 强一致 | < 1万 | QPS 低、无热点、追求简单 |
| Redis Lua + 异步落库 | ⭐⭐⭐ | Redis + MySQL | 最终一致 | 10万+ | 有热点用户、需要低延迟 ⬅ 推荐 |
| Redis + MySQL 双写 | ⭐⭐⭐ | Redis + MySQL | 强一致 | < 5000 | 数据零丢失、可接受性能下降 |
| Redis Cluster + 本地缓存 | ⭐⭐⭐⭐ | Redis Cluster | 最终一致 | 100万+ | 极致性能、超大规模 |

### 9.7 优化建议

根据业务场景选择优化方向：

```
┌─────────────────────────────────────────────────────────────────────┐
│                         优化决策树                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  当前 QPS < 10万？                                                  │
│  ├─ 是 → 当前方案足够                                               │
│  └─ 否 → 方案 B：Redis Cluster 分片                                 │
│                                                                     │
│  能接受 5秒数据窗口？                                               │
│  ├─ 是 → 当前方案足够                                               │
│  └─ 否 → 方案 A：缩短到 1秒                                         │
│          或 方案 D：双写（强一致）                                   │
│                                                                     │
│  需要 < 0.1ms 延迟？                                                │
│  ├─ 否 → 当前方案足够                                               │
│  └─ 是 → 方案 C：本地预分配                                         │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

- **短期建议**：将同步间隔从 5 秒缩短到 1 秒，简单有效
- **中期建议**：如 QPS 增长超过 10 万，引入 Redis Cluster
- **长期建议**：根据业务 SLA 要求，评估是否需要双写方案

---

## 附录

### A. 监控方案

#### A.1 HTTP API 监控

| 接口 | 方法 | 说明 |
|------|------|------|
| /api/v1/resource/metrics | GET | 获取 JSON 格式的监控指标 |
| /api/v1/resource/health | GET | 健康检查接口 |

**使用示例**

```bash
curl http://localhost:8000/api/v1/resource/metrics
```

**响应示例**：

```json
{
  "uptime_seconds": 3600,
  "deduct": {
    "total": 125000,
    "success": 124500,
    "failed": 480,
    "redis_error": 20,
    "latency_ms": 1
  },
  "recharge": {
    "total": 1200,
    "success": 1195,
    "error": 5
  },
  "fallback": {
    "entered": 2,
    "exited": 2
  },
  "sync": {
    "total": 720,
    "errors": 3,
    "logs": 125000
  },
  "cache": {
    "local_hits": 45000,
    "local_misses": 80000,
    "idempotent_hits": 150
  }
}
```

#### A.2 已实现的指标

| 指标名称 | 类型 | 说明 | 告警阈值建议 |
|----------|------|------|-------------|
| deduct.total | Counter | 扣减请求总次数 | - |
| deduct.success | Counter | 扣减成功次数 | - |
| deduct.failed | Counter | 扣减失败次数（余额不足） | - |
| deduct.redis_error | Counter | Redis 错误次数 | > 10/min |
| deduct.latency_ms | Gauge | 扣减延迟（毫秒） | > 10ms |
| fallback.entered | Counter | 进入降级模式次数 | > 0 立即告警 |
| sync.errors | Counter | 同步失败次数 | > 5/hour |
| changelog_length | Gauge | 变更日志队列长度 | > 10000 |

#### A.3 Go 代码使用示例

```go
package main

import (
    "encoding/json"
    "net/http"

    "app/service/resource"
)

func main() {
    // 初始化资源服务
    resource.Init(resource.DefaultConfig())
    svc := resource.GetService()

    http.HandleFunc("/api/v1/resource/metrics", func(w http.ResponseWriter, r *http.Request) {
        metrics := resource.GetMetrics().GetSnapshot()
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(metrics)
    })

    http.HandleFunc("/api/v1/resource/health", func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
            "status":        "healthy",
            "fallback_mode": svc.IsFallbackMode(),
        })
    })

    http.ListenAndServe(":8000", nil)
}
```

### B. 参考资料

- [Redis Lua 脚本官方文档](https://redis.io/docs/interact/programmability/eval-intro/)
- [Asynq 官方文档](https://github.com/hibiken/asynq)
- [Kafka 官方文档](https://kafka.apache.org/documentation/)
- [Seata 分布式事务](https://seata.io/)

---

**文档版本**: v1.0.0
**最后更新**: 2026-01-28
